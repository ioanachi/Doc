Course https://app.pluralsight.com/course-player?clipId=238ebbd4-dd36-49ea-aaed-483072cbe8ef for NUMPY


- np.array = creaza un array np din o lista python
- np.zeros(rows, cols) - creaza un arr de 0 de shape-ul ala
- np.ones(rows, cols) - creaza un arr de 1 de shape-ul ala
-dtype = param pasat la np ca sa il faca de un tip anume  = np.int16
- np.empty = creaza un arr empty
- np.eye = matricea identica

- np.ones_like =creaza array identic cu arr pasat de aceeasi forma dar de cate 1's

- np.arrange - (start, stop, step)
- pass a list of lists to create 2 d arr  - np.array([(2,4,5), (3,5,7)])

- np.shape -row, cols
- ap.arange(24).reshape(2,3,4) - are 2 arr de shape(3,4)

- ca sa scapi de ... sau elipsis faci np.set_printoption(threshold = np.nan)



Operations:
arr1+arr2
arr1*arr2
- matrix multiplication prin A.dot(B) sau np.dot(A,B)

modify an arr rather than  create a new one a  *= 3
- arr.sum - face sumatie
- arr.min-cauta min
- arr.max-cauta max
arr.sum(axis = 0) - face sumatie pe coloana
arr.sum(axis = 1) - face sumatie pe row

Universal functions
- apply functions to arrays!!! angles = np.array([0,30,45,60,90]) 
angles_radians = angles * np.pi/180
- np.sin(angles_radians)]
- angles_radians = np.radians(angles) - convert to radians
- print('Cosine of angles in the array:')
print(np.cos(angles_radians))

Statistical Functions:
test_scores = np.array([32.32, 56.98, 21.52, 44.32, 
                        55.63, 13.75, 43.47, 43.34])
mean      = np.mean(salaries)
median   = np.median(salaries)
sd            = np.std(salaries)
variance  = np.var(salaries)

Indexing and Sliceing

- a[:7] - de la 0 la index 6
- a[2:] - de la 2 la index sf
- a[2:-2] -  merge de la index 2 la penultimul element
- a[:11:2]  - incepe de index 0 pana la 11 cu step de 2

- step in array invers a[: :-1] - stepul este de 1 de la sfarsit

Arrays don't have the same type of data

2D aArrays Indexing:
students = np.array([['Alice','Beth','Cathy','Dorothy'],
                     [65,78,90,81],
                     [71,82,79,92]])
-students[0] - access first row
-students[2] - access second row
- range of accessed elements in a arr  - -students[0:2 ,  2: 4 ] - access rows 0, 1 from columns 2,3 
- Range with no numbers means all rows : students[  : , 1 : 2 ] all rows from column 1

students[-1 , : ] - last row  and all columns
students[:] - all rows and columns
- 3rd from last to second from last row, last two columns: students[-3 :-1, -2 : ] - ultimele randuri -2 si 3 si de la penultima coloana la ultima coloana

Dots or elipsis:
 - Slicing can also include ellipsis (â€¦) to make a selection tuple of the same length as the dimension of an array. The dots (...) represent as many colons as needed to produce a complete indexing tuple

 - students[0] or students[ 0 : 1, : ]  == students[ 0, ... ] 

 - students[...,1] - all rows and the first column

Flatten allows to iterate over every element of an array
for element in students.flatten():
print element - printeaza toate elementele desi students e un array de 3 arraiuri

Row major flattening elements in a row appear together
 
Iterating over multidimensional arrays:
1. Flatten returns a result array

array.flatten( order = 'F')- column major flattening elements in a column appear together

2. nditer - aloows iteration over array
Efficient multi-dimensional iterator object to iterate over arrays

 -  for i in np.nditer(x)  row wise iteration similar to fattened array
 - for i in np.nditer(x,    order = 'F') -  order = 'F' means flattened column wise

-  for i in np.nditer(x, order = 'F', flags = ['external_loop']):  - iterate column wise, each column is a 1D array

 the nditer treats the input array as a read-only object - can't modify the element
- you can modify it if you pass the flag op_flags = ['readwrite']

for arr in np.nditer(x, op_flags = ['readwrite']):
    arr[...] = arr * arr


D. Changing the shape of an array:

1. a.ravel() - flattens the array to a 1 D vector

2. a.T - transposes the array from columns to rows

3. a.reshape()

ex: a = [[1,2,34,], [5,6,7,8]] = shape (2,4)
a.reshape(4,2)

=> a =[ [1,2],
              [5,6],
							[3,4],
              [7,8] ]

reshape with neagtive values means that we don't know the value of that dimension
countries.reshape(-1, 3) - means we need 3 columns but don't know the value for rows
 when you reshape you ned to be abble to divide the nr of the original array to the nr of the reshape

E. Splitting
- np.split(x, 3) - split in 3 equal sized subarrays

You can split an image array  with np.split(imgarr, 2, axis = 1)
axis = 1 -split horizontaly - row
axis = 0 split vertically

np.concatenate -  concatenate the imgs - stacks tha array one on top of the other -  vertically along the column 

F. Views - shallow copies of an array

- any edit on the copy reflect in the original Array
-  contents are the same but they are unique objects - different objects

viewShallowCopy is origImage? - False
viewShallowCopy.base is origImage? - True   - the base from which the view is created is the origImage

- al the views and the original Arrray are affected by a modification to the original Array or a view
-  you can reshape a view or a shallow copy without affecting the original array

G. Deep Copy of an Arrray
fruits = np.array([1,2,3,4,5])
basket = fruits.copy()
- the 2 arrays are different objects and the copy.base is different from the original array
- o modificare a copiei inclusiv forma nu schimba array-ul original

H. Indexing with Arrays Of Indices
a = np.arange(12)**2    =>[  0,   1,   4,   9,  16,  25,  36,  49,  64,  81, 100, 121]

- accesarea indexilor 2,6,8 se poate face:
    1.a[2],a[6],a[8]
    2.a[[2,6,8]]
- the shape of a result of an index matches the shape of the index arrays and not the shape of the array being indexed

















